#### 算法的时间复杂度和空间复杂度称为算法的复杂度
        时间复杂度
        
            可以理解为一个算法在执行一个规模为n的问题时,所需要的时间，这个n可以理解一个函数的入参，比如排序时，n就是待排序的数组的大小
            但实际上，一个算法的执行的时间从理论上是无法算出来的，除非上机测试，但是我们不可能也没必要对每一个改动，每一个算法都进行实际测试， 
            一个算法时间复杂度本质上与这个算法解决这个规模n的问题时所执行的语句次数有关系，而这个执行所需的次数是问题规模n的某个函数
            
            我们假设问题规模为n , 算法解决这个规模n的问题需要的时间用函数 T(n) 表示
            若存在一个辅助函数 f(n) ,使得 n趋于无穷大时， T(n) / f(n) 约等于一个不为0的常数  则f(n) 是 T(n) 的同数量级函数
            记做 T(n) = O(f(n)) ，则称 O(f(n)) 为算法的渐进时间复杂度
            常见的时间复杂度 有 O(1)常数阶  O(n)线性阶   O(log2n)对数阶   O(nlog2n)n倍对数阶  O(n2)平方阶   O(n3) 立方阶    O(2n) 指数阶
            O(1)指的是算法的时间复杂度不随着问题规模n的增加而增长，执行时间不过一个较大的常数  
            时间复杂度是总运算次数表达式中受n的变化影响最大的那一项(不含系数) 
            
        时间复杂度的常见分类
            最好时间复杂度
            最坏时间复杂度
            平均时间复杂度（加权平均值）
            均摊时间复杂度（一种特殊的平均时间复杂度）
        时间复杂度常见的分析方法
            只关注循环执行次数最多的一段代码
            加法法则：总的时间复杂度等于量级最大的那段代码的时间复杂度
            乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
            摊还分析法：把耗时最多的那次平均分摊在截下来的n次中
            
        还有一种时间复杂度是由两个数据规模来决定的：
            O(m+n)
            O(m*n)    
                   
        
        空间复杂度
        
            可以理解为对一个算法在执行规模为n的问题时临时占用的存储空间的大小 记做 S(n) = O(f(n))     
            关于O(1)的问题， O(1)是说数据规模和临时变量数目无关，并不是说仅仅定义一个临时变量。举例：无论数据规模多大，我都定义100个变量，这就叫做数据规模和临时变量数目无关。就是说空间复杂度是O(1)
            
           